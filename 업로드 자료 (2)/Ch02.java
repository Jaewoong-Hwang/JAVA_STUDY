
public class Ch02 {
	public static void main(String[] args) {
		// 01 진수
		// 진수(진법) : 정수를 표현할 때 사용되는 수 표현방법.
		// JAVA는 기본적으로 10진수를 사용, 정수 리터럴을 작성할 때는 10진수가 기본적으로 사용됨.
		
		// 10진수 			--> 			2진수
		// 0								0
		// 1								1
		// 2								10
		// 3								11
		// 4								100
		// 5								101
		// 6								110
		// 7								111

		// 02 서식문자를 사용한 진수 표현법
//		System.out.println("--------------- 진수와 서식문자 예제 ---------------");
//		//10진수로 변환							
//		System.out.printf("10진수 : %d\n", 0b10101101);	//0b	: 2진수
//		System.out.printf("10진수 : %d\n", 173);			//		: 10진수
//		System.out.printf("10진수 : %d\n", 0255);			//0		: 8진수
//		System.out.printf("10진수 : %d\n", 0xAD);			//0x	: 16진수
//		System.out.println();
//		
//		//8진수로 변환
//		System.out.printf("08진수 : %o\n", 0b10101101);	//0b	: 2진수
//		System.out.printf("08진수 : %o\n", 173);			//		: 10진수
//		System.out.printf("08진수 : %o\n", 0255);			//0		: 8진수
//		System.out.printf("08진수 : %o\n", 0xAD);			//0x	: 16진수
//		System.out.println();
//		
//		//16진수로 변환
//		System.out.printf("16진수 : %x\n", 0b10101101);	//0b	: 2진수
//		System.out.printf("16진수 : %x\n", 173);			//		: 10진수
//		System.out.printf("16진수 : %X\n", 0255);			//0		: 8진수
//		System.out.printf("16진수 : %X\n", 0xAD);			//0x	: 16진수
//		System.out.println();
		
//		
//		==> 컴퓨터는 내부적으로 모든 값을 이진(binary) 데이터로 저장하고 있음
//			우리가 보는 것은 다양한 진법의 리터럴을 통해 그 값을 해석한것 뿐임. == 형식 지정자(서식문자)에 맞게 표현한 것 뿐임.
		
		// 03 이진 데이터(2진수)의 양수 표현 방식
		
		// 컴퓨터는 10진수 데이터를 2진수 데이터로 변환하여 저장되는데
		// 이때 2진수로 변환된 데이터 하나를 담는 최소 공간단위 == 비트 (bit)
		
		
		// ###
		// 1 byte == 8 bit
		// ###
		
		// 2진수를 10진수로 변환할 때 계산하는 방법
		// 1	1	1	1		1	1	1	1
		// 128	64	32	16		8	4	2	1 ==> 255	
		
		
		// 10진수		->		2진수
		// 
		// 1		->		1			1비트가 사용됨.
		// 2		->		10			2비트가 사용됨.
		// 3		->		11			2비트가 사용됨.
		// 4		->		100			3비트가 사용됨.
		// 5		->		101			3비트가 사용됨.
		// 8		->		1000		4비트가 사용됨.
		// 31		->		11111		5비트가 사용됨.
		// 44		->		101100		6비트가 사용됨.
		// 112		->		1110000		7비트가 사용됨.
		// 255		->		11111111	8비트가 사용됨.
		// 256		->		100000000	9비트가 사용됨.
		
		
		// 10진수를 2진수로 변환하는 문제!
		// 
		// 10		->		1010
		// 12		->		1100
		// 20		->		1 0100
		// 59		->		11 1011
		// 72		->		100 1000
		// 42		->		10 1010
		// 160		->		1010 0000
		
		// 2진수를 10진수로 변환하는 문제!
		// 
		// 11000001	->		128 + 64 + 1 		==> 193
		// 01011101	->		64 + 16 + 8 + 4 + 1 ==> 93
		// 00001011	->		8 + 2 + 1 			==> 11
		
		
		
		// 04 이진 데이터(2진수)의 음수 표현 방식
		
		// CPU는 가산기(가산회로)에 의해서 데이터에 대한 덧셈연산을 할 수 있다? O
		// CPU는 감산기(감산회로)에 의해서 데이터에 대한 뺄셈연산을 할 수 있다? X
		// CPU는 애초에 가연산에 특화되어 있는 명령 처리 장치이다.
		
		// 8비트공간에 음수를 저장할 수 있다.
		// 8비트에서 부호를 지원한다면 제일 앞 비트는 부호 비트이다! 
		// 부호비트가 0이면 양수 <-------------------> 1이면 음수
		
		// 컴퓨터의 뺄셈 처리는 '보수' 개념을 이용해서 음수를 양수화 하여
		// 계산하는데 이는 뺄셈 결과와 동일한 결과가 나옴.
		
		// A - B는 A + (B의 보수)로 바꾸어 계산함.
		
		
		
		// ## 보수의 개념 ##
		
		// 보수란? : 각 자리의 숫자의 합이 일정한 수가 되게 하는 수
		// 즉 어느 수에 대한 반전, 뒤집는 개념
		
		//N진수라면 보수가 두가지 존재함.
		//1. N - 1의 보수
		//2. N의 보수
		//Ex) 10진수에는 10의 보수와 9의 보수가 존재
		//   2진수에는  2의 보수와 1의 보수가 존재
		
		// 1에 대한 10의 보수는 9
		// 2에 대한 10의 보수는 8
		// 3에 대한 10의 보수는 7 
		// 4에 대한 10의 보수는 6
		
		// 3에 대한 9의 보수는 6
		// 5에 대한 9의 보수는 4
		// ---------------------------
		// 일정 수를 기준으로 반대되는 수 == 보수
		
		
		// 33에 대한 9의 보수는 66
		// 33에 대한 10의 보수는 67
		// ---------------------------------
		// 어? 여기서 알 수 있는 것
		// n의 보수 == n-1의 보수에서 1을 더했을 때 '자릿수가 올라가는 수'
		// n의 보수 == n-1의 보수 + 1
		
		// 1) 1의 보수 구하는 법
		
		// 1의 보수 : 각 자릿수의 값이 모두 1인 수에서 2진수를 뺀 수
		//			쉽게 말해 합쳐서 1111 1111이 되는 수
		
		// Ex)
		// 10진수			->			2진수 
		// 5			->			0000 0101
		
		// 1111 1111
		// 0000 0101  -
//		--------------------
		// 1111 1010 	-> 			5에 대한 1의 보수
		// 1111 1011 	->			5에 대한 2의 보수
		
		// 5 - 5 = 0
		// 0000 0101 - 0000 0101
		
		// 0000 0101 + (5에 대한 2의 보수)
		// 0000 0101 + 1111 1011 = 1 0000 0000
		// -----------------------------------------
		// 자릿수가 증가한다면 버리고 나머지를 계산
		// 1(버림) 0000 0000
		//        --------- 해당 부분만 계산
		// 0000 0000 = 0
		
		
		

		// 2) 1의 보수를 간단하게 구하는 법
		// 
		// 해당 2진수를 반전시키면 1의 보수다
//				10진수	---->	2진수
		// Ex)	5		---->	101  
//			--------------------------------
		// 10진수 5에 대한 1의 보수는 010
		// 10진수 5에 대한 2의 보수는 011  
		
		

		// 문제) 각 10진수를 2진수로 변환 후에 1의보수와 2의 보수를 구해보자 !!!

		//  10		->		0000 1010 (이진수)
		//	  		->		1111 0101 (1의보수)
		//				   +0000 0001
		//--------------------------
		// -10				1111 0110 (2의보수)
		//
		// 8		->		0000 1000 (이진수)
		//			    	1111 0111 (1의보수)
		//			       +0000 0001 
		//	--------------------------
		// -8		->		1111 1000 (2의보수)
		// 
	
		//  20		->		0001 0100 (이진수)
		//			->		1110 1011 (1의보수)
		//				   +0000 0001
		//--------------------------
		// -20				1110 1100 (2의보수)
		//
		// 120		->		0111 1000 (이진수)
		//			    	1000 0111 (1의보수)
		//			       +0000 0001 
		//	--------------------------
		// -120		->		1000 1000 (2의보수)
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}
